#include <stdbool.h>

#include "element_wise.h"
#include "element_wise_ispc.h" // generated by ispc


static void VS_CC invertInit(VSMap *in, VSMap *out, void **instanceData, VSNode *node, VSCore *core, const VSAPI *vsapi) {
    InvertData *d = (InvertData *) * instanceData;
    vsapi->setVideoInfo(d->vi, 1, node);
}

static const VSFrameRef *VS_CC invertGetFrame(int n, int activationReason, void **instanceData, void **frameData, VSFrameContext *frameCtx, VSCore *core, const VSAPI *vsapi) {
    InvertData *d = (InvertData *) * instanceData;

    if (activationReason == arInitial) {
        vsapi->requestFrameFilter(n, d->node, frameCtx);
    } else if (activationReason == arAllFramesReady) {
        const VSFrameRef *src = vsapi->getFrameFilter(n, d->node, frameCtx);

        const int pl[] = { 0, 1, 2 };
        const VSFrameRef *fr[] = {d->process[0] ? 0 : src, d->process[1] ? 0 : src, d->process[2] ? 0 : src};
        VSFrameRef *dst = vsapi->newVideoFrame2(d->vi->format, d->vi->width, d->vi->height, fr, pl, src, core);

        for (int plane = 0; plane < d->vi->format->numPlanes; plane++) {
            if (d->process[plane]) {
                int stride = vsapi->getStride(src, plane) / d->vi->format->bytesPerSample;
                int height = vsapi->getFrameHeight(src, plane);
                int width = vsapi->getFrameWidth(src, plane);
                const uint8_t * VS_RESTRICT srcp = vsapi->getReadPtr(src, plane);
                uint8_t * VS_RESTRICT dstp = vsapi->getWritePtr(dst, plane);

                if (d->vi->format->sampleType == stInteger) {
                    if (d->vi->format->bytesPerSample == 1) {
                        Invert_i8(srcp, dstp, width, height, stride);

                    } else if (d->vi->format->bytesPerSample == 2) {
                        if (d->vi->format->bitsPerSample == 16) {
                            Invert_i16((const uint16_t *)srcp, (uint16_t *)dstp, width, height, stride);
                        } else {
                            const uint16_t peak = (1 << d->vi->format->bitsPerSample) - 1;

                            Invert_i16m((const uint16_t *)srcp, (uint16_t *)dstp, width, height, stride, peak);
                        }
                    }
                } else if (d->vi->format->sampleType == stFloat) {
                    if (d->vi->format->bytesPerSample == 4) {
                        const bool uv = (plane > 0) && ((d->vi->format->colorFamily == cmYUV) || (d->vi->format->colorFamily == cmYCoCg));

                        Invert_f32((const float *)srcp, (float *)dstp, width, height, stride, uv);
                    }
                }
            }
        }

        vsapi->freeFrame(src);
        return dst;
    }

    return 0;
}

static void VS_CC invertFree(void *instanceData, VSCore *core, const VSAPI *vsapi) {
    InvertData *d = (InvertData *)instanceData;
    vsapi->freeNode(d->node);
    free(d);
}

void VS_CC invertCreate(const VSMap *in, VSMap *out, void *userData, VSCore *core, const VSAPI *vsapi) {
    InvertData d;
    InvertData *data;

    d.node = vsapi->propGetNode(in, "clip", 0, 0);
    d.vi = vsapi->getVideoInfo(d.node);

    int num_planes = d.vi->format->numPlanes;
    const int m = vsapi->propNumElements(in, "planes");

    for (int i = 0; i < 3; i++)
        d.process[i] = (m <= 0);

    for (int i = 0; i < vsapi->propNumElements(in, "planes"); i++) {
        int plane = int64ToIntS(vsapi->propGetInt(in, "planes", i, 0));

        if (plane < 0 || plane >= num_planes) {
            vsapi->freeNode(d.node);
            vsapi->setError(out, "Invert: plane index out of range");
            return;
        }

        if (d.process[plane]) {
            vsapi->freeNode(d.node);
            vsapi->setError(out, "Invert: plane specified twice");
            return;
        }

        d.process[plane] = true;
    }

    data = malloc(sizeof(d));
    *data = d;

    vsapi->createFilter(in, out, "Invert", invertInit, invertGetFrame, invertFree, fmParallel, 0, data, core);
}
